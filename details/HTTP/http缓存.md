[(1.6w字)浏览器与前端性能灵魂之问，请问你能接得住几个？（上）](https://juejin.im/post/6844904021308735502#heading-0)

[深入理解浏览器的缓存机制](https://www.jianshu.com/p/54cc04190252)

[浏览器缓存看这一篇就够了](https://segmentfault.com/a/1190000018717463)

# HTPP缓存：强缓存、协商缓存
![](/img/HTTP/缓存.jpg)


## 强缓存

强缓存两个相关字段，`Expires`，`Cache-Control`。
* HTTP1.0版本，使用的是Expires，
* HTTP1.1版本，使用的是Cache-Control

「强缓存分为两种情况，一种是发送HTTP请求，一种不需要发送。」

### Expires 过期时间
时间是相对于服务器的时间而言的，存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求
  ```js
  Expires:Mon, 29 Jun 2020 11:10:23 GMT
  // 表示该资源在2020年7月29日11:10:23过期，过期时就会重新向服务器发起请求。
  ```

![](/img/HTTP/expires.png)

这个方式有一个问题：`服务器的时间和浏览器的时间可能并不一致`，所以HTTP1.1提出新的字段代替它。

### Cache-Control 过期时长; 优先级高于 Expires
* private：只有客户端可以缓存，默认值
* max-age=xxx （单位为s）：缓存内容将在xxx秒后失效
* public：都将被缓存（客户端和代理服务器都可缓存）
* no-cache：跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。
* no-store：都不会被缓存，即不使用强制缓存，也不使用协商缓存
* s-maxage=xxx（单位为s）：类似max-age，并会覆盖max-age，区别在于s-maxage是针对代理服务器的缓存时间。

![](/img/HTTP/max-age.png)
```js
Cache-control: max-age=30 
// 表示资源会在 30 秒后过期，需要再次请求。
```

## 协商缓存
强缓存失效后，浏览器在请求头中携带响应的缓存Tag来向服务器发送请求，服务器根据对应的tag，来决定是否使用缓存,这就是协商缓存。

协商缓存分为两种
* Last-Modified
* ETag

两者各有优势，并不存在谁对谁有绝对的优势，与上面所讲的强缓存两个Tag所不同。

### Last-Modified 最后修改时间
在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

浏览器接收到后，「如果再次请求」，会在请求头中携带 `If-Modified-Since` 字段，这个字段的值也就是服务器传来的最后修改时间。

服务器拿到请求头中的 `If-Modified-Since` 的字段后，其实会和这个服务器中该资源的最后修改时间对比:
* 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
* 否则返回304，告诉浏览器直接使用缓存


### ETag 服务器根据当前文件的内容，对文件生成唯一的标识
浏览器接受到ETag值，会在下次请求的时候，将这个值作为 `If-None-Match `这个字段的内容，发给服务器。

服务器接收到 `If-None-Match` 后，会跟服务器上该资源的 `ETag` 进行比对
* 如果不一样的话，说明内容更新了，返回新的资源，跟常规的HTTP请求响应的流程一样
* 如果两者一样的话，直接返回304，告诉浏览器直接使用缓存

### Last-Modified、ETag 两者对比
* 性能上，Last-Modified优于ETag，Last-Modified记录的是时间点，而Etag需要根据文件的MD5算法生成对应的hash值。

* 精度上，ETag优于Last-Modified。ETag按照内容给资源带上标识，能准确感知资源变化，Last-Modified在某些场景并不能准确感知变化，比如
  * 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
  * Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。

最后，「如果两种方式都支持的话，服务器会优先考虑ETag」


### 选择合适的缓存策略
* 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存
* 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
* 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹(hash)处理，一旦文件名变动就会立刻下载新的文件。


## 用户操作行为与缓存的关系
![](/img/HTTP/用户行为与缓存关系.png)
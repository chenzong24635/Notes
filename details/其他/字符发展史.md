# [字符发展史](http://www.zhufengpeixun.com/grow/html/8.Encoding.html)

## 字节
计算机内部，所有信息最终都是一个二进制值
每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节(byte)

![](/img/others/bits.jpg)

总结
* 字节是计算机存储的计量单位，是通过网络传输信息的基本单位，一字节等于8位二进制数
* 一位代表一个 0 或 1，每8位（bit）组成一字节（Byte）
* 字节最大值的十进制是255(2**8-1)


## 单位换算
* 8位 = 1字节
* 1024字节 = 1K
* 1024K = 1M
* 1024M = 1G
* 1024G = 1T

## 进制
* 0b 二进制
* 0o 八进制
* 0 十进制
* 0x 十六进制

### 进制转换
* val.toString(n) // 十进制转为 n进制
* parseInt(str,n) // n进制转为十进制

```js
// 十进制转为 二进制
(3).toString(2) // '11'

// 十进制转为 八进制
(9).toString(8) // '11'

// 十进制转十六进制
(17).toString(16) // '11'

```

```js
// 
// 二进制转十进制
parseInt('11',2) // 3 
// 八进制转十进制
parseInt('11',8) // 9
// 十六进制转十进制
parseInt('11',16) // 17  -->1*16**1 + 1*16**0
```

## 发展
* ASCII (最开始计算机只在美国用，128个符号)
* GB2312
  * (后来西欧一些国家用的不是英文，他们使用127号这后的空位来保存新的字母，一直编到了最后一位255。)
  * 中国为了表示汉字，把127号之后的符号取消了，规定
    * 一个小于127的字符的意义与原来相同，但两个大于 127 的字符连在一起时，就表示一个汉字；
    * 前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从 0xA1 到 0xFE；
    * 这样我们就可以组合出大约7000多个(247-161)*(254-161)=(7998)简体汉字了。
    * 还把数学符号、日文假名和ASCII里原来就有的数字、标点和字母都重新编成两个字长的编码。这就是全角字符，127以下那些就叫半角字符。
    * 把这种汉字方案叫做 GB2312。GB2312 是对 ASCII 的中文扩展
* GBK (后来还是不够用，于是干脆不再要求低字节一定是 127 号之后的内码，只要第一个字节是大于 127 就固定表示这是一个汉字的开始,又增加了近 20000 个新的汉字（包括繁体字）和符号。)
* GB18030 / DBCS (又加了几千个新的少数民族的字，GBK扩成了GB18030 通称他们叫做 DBCS)
*  Unicode(Universal Multiple-Octet Coded Character Set，简称 UCS) (ISO 的国际组织废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符 的编码！ Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。)
   *  规定必须用两个字节，也就是 16 位来统一表示所有的字符，对于 ASCII 里的那些 半角字符，Unicode 保持其原编码不变，只是将其长度由原来的 8 位扩展为16 位，而其他文化和语言的字符则全部重新统一编码。

  * 从 Unicode 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的一个字符！同时，也都是统一的 两个字节
    * 字节是一个8位的物理存贮单元，
    * 而字符则是一个文化相关的符号。

* UTF-8(Unicode 在很长一段时间内无法推广，直到互联网的出现，为解决 Unicode 如何在网络上传输的问题，于是面向传输的众多 UTF 标准出现了，)
  >Universal Character Set（UCS）Transfer Format：UTF编码

  * UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式
  * UTF-8就是每次以8个位为单位传输数据
  * 而UTF-16就是每次 16 个位
  * UTF-8 最大的一个特点，就是它是一种变长的编码方式
  * Unicode 一个中文字符占 2 个字节，而 UTF-8 一个中文字符占 3 个字节
  * UTF-8 是 Unicode 的实现方式之一

## base64
[base64](/details\文件处理\base64.md)

## Buffer
[Buffer](/details\Node\属性\Buffer.md)
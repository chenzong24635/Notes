# 实现数组函数串行执行
串行（Serial）：是指两个或多个事件按顺序执行，完成一个之后才能进行下一个，同步线程的实现方式

```js
function promise(n){
  return function(){
    return new Promise((resolve,reject) => {
      setTimeout(()=>{
        console.log(n);
        resolve(n)
      }, n*1000)
    })
  }
}
let arrs = [
  promise(9),
  promise(1),
  promise(2),
  promise(3),
]
```

## reduce 实现
```js

function arrayFns(fns){
  fns = Array.isArray(fns) ? fns : [fns]
  // 使用reduce创建Promise回调链
  fns.reduce((prev, next) => {
    return prev.then(()=>next())
  } ,Promise.resolve())
}
arrayFns(arrs)
```

## for await of 实现
```js
async function arrayFns(fns){
  fns = Array.isArray(fns) ? fns : [fns]
  for await(let fn of fns){
    fn()
  }
}
arrayFns(arrs)
```

# 面试题
页面上有一个输入框，两个按钮，A按钮和B按钮，点击A或者B分别会发送一个异步请求，请求完成后，结果会显示在输入框中。

题目要求，用户随机点击A和B多次，要求输入框显示结果时，按照用户点击的顺序显示，举例：

用户点击了一次A，然后点击一次B，又点击一次A，输入框显示结果的顺序为先显示A异步请求结果，再次显示B的请求结果，最后再次显示A的请求结果。

```js
//dom元素
var a = document.querySelector("#a")
var b = document.querySelector("#b")
var i = document.querySelector("#ipt");
//全局变量p保存promie实例
var P = Promise.resolve();
a.onclick  = function(){
  //将事件过程包装成一个promise并通过then链连接到
  //全局的Promise实例上，并更新全局变量，这样其他点击
  //就可以拿到最新的Promies执行链
  P = P.then(function(){
    //then链里面的函数返回一个新的promise实例
    return new Promise(function(resolve,reject){
      setTimeout(function(){
        resolve()
        i.value = "a";
      },1000)
    })
  })
}
b.onclick  = function(){
  P = P.then(function(){
    return new Promise(function(resolve,reject){
      setTimeout(function(){
        resolve()
        console.log("b")
        i.value = "b"
      },2000)
    })
  })
}
```

# 字节面试题，实现一个异步加法
```js

function asyncAdd(a, b, callback) {
  setTimeout(function () {
    callback(null, a + b);
  }, 500);
}

// 解决方案
// 1. promisify
const promiseAdd = (a, b) => new Promise((resolve, reject) => {
  asyncAdd(a, b, (err, res) => {
    if (err) {
      reject(err)
    } else {
      resolve(res)
    }
  })
})

// 2. 串行处理
async function serialSum(...args) {
  return args.reduce((task, now) => task.then(res => promiseAdd(res, now)), Promise.resolve(0))
}

// 3. 并行处理
async function parallelSum(...args) {
  if (args.length === 1) return args[0]
  const tasks = []
  for (let i = 0; i < args.length; i += 2) {
    tasks.push(promiseAdd(args[i], args[i + 1] || 0))
  }
  const results = await Promise.all(tasks)
  return parallelSum(...results)
}

// 测试
(async () => {
  console.log('Running...');
  const res1 = await serialSum(1, 2, 3, 4, 5, 8, 9, 10, 11, 12)
  console.log(res1)
  const res2 = await parallelSum(1, 2, 3, 4, 5, 8, 9, 10, 11, 12)
  console.log(res2)
  console.log('Done');
})()

```
## <a name="深，浅拷贝">深，浅拷贝</a>
[如何写出一个惊艳面试官的深拷贝](https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1)

[浅拷贝与深拷贝](https://juejin.im/post/5b5dcf8351882519790c9a2e)

https://juejin.im/post/5df7175fe51d45582512962c

### 浅拷贝： 浅拷贝只复制指向某个对象的指针，即复制对象地址
创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了，就会影响到另一个对象。

* Object.assign(a, b, c)
  >第一个参数是目标对象，后面的参数都是源对象
   是一种可以对非嵌套对象进行深拷贝的方法,如果对象中出现嵌套情况,那么其对被嵌套对象的行为就成了普通的浅拷贝.

* 扩展运算符
  >b = {...a}


* slice
  > b = a.slice(0)

* concat
  >b = a.concat([])


### 深拷贝：开辟新的栈  
将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象


* JSON.parse(JSON.stringify(obj))
  - 只能正确处理的对象只有 Number, String, Boolean, Array，扁平对象 即那些能够被json直接表示的数据结构。
  - 会忽略 undefined、会忽略 symbol、NaN会转化为null。
  - 不能处理循环引用的对象,报错。
  - 不能正确处理new Date()。(转换结果不正确)
  - 不能处理正则。(直接解析为空对象{})
  - 不能序列化函数。

循环引用的情况：
```js
let obj = {
    a: 1,
    b: {
      c: 2,
    }
}
obj.a = obj.b;
obj.b.c = obj.a;

let b = JSON.parse(JSON.stringify(obj));
//Uncaught TypeError:Converting circular structure to JSON
```

序列化函数：通过操作JSON.parse,JSON.stringify的第二个参数
```js
let obj = {
    a: 1,
    func:function(){return this.a}
}

let b = JSON.parse(JSON.stringify(obj, function(key, val) {
  if (typeof val === 'function') {
    return val + '';
  }
  return val;
}),function(key, val){
  if(val.indexOf && val.indexOf('function')>-1){
    return eval("(function(){return "+ val +" })()")
  }
  return val;
});
console.log(obj,b,b.func())
```

* [函数库lodash](https://www.lodashjs.com/),  [lodash-CDN](https://www.bootcdn.cn/lodash.js/)  提供_.cloneDeep 深拷贝方法

* 实现深拷贝
```js
//定义检测数据类型的功能函数
function checkedType(target) {
  return Object.prototype.toString.call(target).slice(8, -1)
}
//实现深度克隆
function deepClone(target) {
  //判断拷贝的数据类型
  //初始化变量 res 成为最终克隆的数据
  let res, targetType = checkedType(target)
  console.log(target,targetType);
  if (targetType === 'Object') {
    res = {}
  } else if (targetType === 'Array') {
    res = []
  }else { // 其他类型直接返回，无需深拷贝
    return target
  }


  //遍历目标数据
  for (let key in target) {
    //获取遍历数据结构的每一项值。
    let val = target[key]
    let type = checkedType(val)
    if(!target.hasOwnProperty(key))continue // 排除继承的属性
    //判断目标结构里的每一值是否存在对象/数组
    switch(type) {
      case 'Object':
      case 'Array':
        //对象/数组
        res[key] = deepClone(val)
        break;
      case 'Date':
        // 日期
        res[key] = new Date(val)
        break;  
      case 'RegExp':
        // 正则
        res[key] = new RegExp(val.source, val.flags)
        break;  
      case 'Error':
        // 错误
        res[key] = new Error(val.message)
        break;  
      default:
        res[key] = val  
    }
  }
  return res
}

var obj = {
  nl: null,
  und: undefined,
  number: 1,
  bool: true,
  str: 'str',
  arr: [],
  obj: {a: 'obj a', b: {arr: [1, 2, 5]}},
  func: function(){console.log(this.obj)},
  error: new Error('my error'),
  date: new Date(),
  reg: /[1-9]/,
  // syb: Symbol.for('Symbolfor'),
  // syb1: Symbol('Symbol'),
}
let obj1 = deepClone(obj);
obj.arr.push(99)
obj1.name= 'obj1'

obj1.obj.a= 'obj1 a'
obj1.obj.b.arr.push('obj1')
console.log(obj);
console.log(obj1);
console.log(obj1.error===obj.error);
console.log(obj1.date===obj.date);
console.log(obj1.reg===obj.reg);
```

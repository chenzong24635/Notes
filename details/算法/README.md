
https://github.com/sl1673495/leetcode-javascript/issues?page=5&q=is%3Aissue+is%3Aopen

https://juejin.im/post/6861376131615227912
https://juejin.im/post/6850418120755494925
https://juejin.im/post/6844904061947346957
https://juejin.im/post/6844903919722692621
https://github.com/sisterAn/JavaScript-Algorithms



 [时间复杂度 O(log n) 意味着什么？ —— 掘金](https://juejin.im/entry/593f56528d6d810058a355f4)
[算法的时间复杂度和空间复杂度 —— 掘金](https://juejin.im/entry/5a49f7d36fb9a0450a67b269)
 [算法（一）时间复杂度 —— 掘金](https://juejin.im/post/58d15f1044d90400691834d4)

# 算法
算法（Algorithm） 代表着用系统的方法描述解决问题的策略机制，可以通过一定规范的 输入，在有限时间内获得所需要的 输出。

算法的好坏是通过 时间复杂度 与 空间复杂度 来衡量的。
>
    时间复杂度：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。
    空间复杂度：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。

简单来说，时间复杂度 就是执行算法的 时间成本 ，空间复杂度 则是执行算法的 空间成本 。


### 时间复杂度
#### 时间频度
一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。


####时间复杂度
前面提到的时间频度T(n)中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称时间复杂度。


### 大O表示法
像前面用O( )来体现算法时间复杂度的记法，我们称之为大O表示法。

算法复杂度可以从最理想情况、平均情况和最坏情况三个角度来评估，由于平均情况大多和最坏情况持平，而且评估最坏情况也可以避免后顾之忧，因此一般情况下，我们设计算法时都要直接估算最坏情况的复杂度。

大O表示法O(f(n)中的f(n)的值可以为1、n、logn、n²等，因此我们可以将O(1)、O(n)、O(logn)、O(n²)分别可以称为常数阶、线性阶、对数阶和平方阶，那么如何推导出f(n)的值呢？我们接着来看推导大O阶的方法。

##### 推导大O阶
推导大O阶，我们可以按照如下的规则来进行推导，得到的结果就是大O表示法：
1.用常数1来取代运行时间中所有加法常数。
2.修改后的运行次数函数中，只保留最高阶项
3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。

#### 常数阶
先举了例子，如下所示。
```js
let sum = 0, n = 10; // 语句执行一次 
let sum = (1+n)*n/2; // 语句执行一次 
console.log(`The sum is : ${sum}`) //语句执行一次 
```
上面算法的运行的次数的函数为f(n)=3，根据推导大O阶的规则1，我们需要将常数3改为1，则这个算法的时间复杂度为O(1)。如果sum = （1+n）*n/2这条语句再执行10遍，因为这与问题大小n的值并没有关系，所以这个算法的时间复杂度仍旧是O(1)，我们可以称之为常数阶。

#### 线性阶
线性阶主要要分析循环结构的运行情况，如下所示。
```js
let i =0; // 语句执行一次 
while (i < n) { // 语句执行n次 
  console.log(`Current i is ${i}`); //语句执行n次
  i++; // 语句执行n次
}

```
这个算法中代码总共执行了 3n + 1次，根据规则 2和3，因此该算法的时间复杂度是O(n)。

#### 对数阶
```js
let number = 1; // 语句执行一次 
while (number < n) { // 语句执行logn次
  number *= 2; // 语句执行logn次
}

```
上面的算法中，number每次都放大两倍，我们假设这个循环体执行了m次，那么2^m = n即m = logn，所以整段代码执行次数为1 + 2*logn，则f(n) = logn，时间复杂度为O(logn)。


#### 平方阶
```js
for (let i = 0; i < n; i++) { // 语句执行n次 
  for (let j = 0; j < n; j++) { // 语句执行n^2次 
     console.log('I am here!'); // 语句执行n^2
  }
}
```
代码共执行 2*n^2 + n，则f(n) = n^2。所以该算法的时间复杂度为O(n^2 )


#### 常见时间复杂度的比较

O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(2ⁿ)<O(n!)
![](/img/算法/时间复杂度.png)


|时间复杂度|非正式术语|
|:--|:--|
|O(1)	|常数阶
|O(n)	|线性阶
|O(n<sup>2</sup>)	|平方阶
|O(n<sup>3</sup>)	|立方阶
|O(2<sup>n</sup>)	|指数阶
|O(n!)	|阶层阶
|O(log n)	|对数阶
|O(n log n)	|线性对数阶

最好时间复杂度： 在最理想情况下执行代码的时间复杂度，它花的时间最短；

最坏时间复杂度： 最糟糕情况下执行代码的时间复杂度，它花的时间最长；

平均时间复杂度： 执行代码时间的平均水平，这个值就是概率论中的加权平均值，也叫期望值。
https://juejin.im/post/5d13a5fce51d455a694f9560

## <a name="作用域、作用域链、执行上下文">作用域、作用域链、执行上下文(执行环境)</a>

### 作用域：
作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期，

JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。


`静态作用域与动态作用域`
* 静态作用域：函数的作用域在函数定义的时候就决定了  
* 动态作用域：函数的作用域在函数调用的时候才决定的


`作用域分类：`
* 全局作用域:
* 局部作用域:
  * 函数作用域
  * 块级作用域
  * eval作用域

### 作用域链：

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

注意：作用域链的顶端是全局作用域，作用域链在变量定义时就已经创建了。

JavaScript中的函数采用静态作用域，也称词法作用域。当在执行函数调用时，不管何时何地执行函数，其中的变量在函数定义时就已经决定了，函数会从自身作用域节点开始，沿着作用域链向上访问变量的值。


### 执行上下文（Execution Context）EC：
[深入理解JavaScript执行上下文和执行栈](https://segmentfault.com/a/1190000018550118)

执行上下文可以理解为当前代码被解析和执行时所在环境，  
在执行JS程序时，每遇到一段JS可执行代码，都会创建一个可执行上下文。


#### 类型
* 全局执行上下文：只有一个，也就是浏览器对象(即window对象)，this指向的就是这个全局对象。
* 函数执行上下文：有无数个，只有在函数被调用时才会被创建，每次调用函数都会创建一个新的执行上下文。
* eval函数执行上下文：js的eval函数执行其内部的代码会创建属于自己的执行上下文, 很少用而且不建议使用。

#### 特性：
* 单线程，只在主线程上运行；
* 同步执行，从上向下按顺序执行；
* 只有一个全局上下文(window)
* 可有无数个函数上下文
* 每个函数调用都会创建一个新的执行上下文，哪怕是递归调用

#### 执行上下文栈 (Execution context stack)ECS
一段JS程序必定会产生多个执行上下文，而JavaScript引擎则是以堆栈的形式来对其进行管理，也就是常说的函数调用栈。 

`特点`：后进先出（LIFO）的结构。

`作用`：存储在代码执行期间的所有执行上下文。

栈底是全局上下文，栈顶则是当前正在执行的上下文.


例
```js
var a = 1; // 1. 全局上下文环境
function bar (x) {
    console.log('bar')
    var b = 2;
    fn(x + b); // 3. fn上下文环境
}
function fn (c) {
    console.log(c);
}
bar(3); // 2. bar上下文环境
```
图：
![](/img/执行上下文.jpg)

图解：
* 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。

* 每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。

* 当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。

* 浏览器的JS执行引擎总是访问栈顶的执行上下文。  

* 全局上下文只有唯一的一个，它在浏览器关闭时出栈。

#### 生命周期:
* 创建阶段
* 执行阶段
* 销毁阶段

##### 创建阶段（函数刚被调用但未执行的时候）:
* 创建变量对象
  - 函数环境会初始化创建Arguments对象（并赋值）
  - 函数声明（并赋值）
  - 变量声明，函数表达式声明（未赋值）
* 确定this指向  
  - this的值是在执行的时候才能确认，定义的时候不能确认.因为this是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候  
* 创建作用域链

##### 执行阶段：
* 变量对象赋值
  - 变量赋值
  - 函数表达式赋值
* 调用函数
* 按顺序执行其它代码


##### 销毁阶段
* 执行完毕出栈，等待回收被销毁 



#### 例
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```
执行上下文栈变化
```js
ECStack.push(<checkscope> functionContext);
ECStack.push(<f> functionContext);
ECStack.pop();
ECStack.pop();
```


```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```
执行上下文栈变化
```js
ECStack.push(<checkscope> functionContext);
ECStack.pop();
ECStack.push(<f> functionContext);
ECStack.pop();
```
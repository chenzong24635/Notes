
#  <a name="运算符">运算符</a>
![运算符优先级](/img/运算符优先级.png)


更多运算符[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

##  <a name="加运算符">+运算符</a>
>
    如果有操作数是对象，转换为原始值  
    此时如果有一个操作数是字符串，其他的操作数都转换为字符串并执行连接  
    否则：所有操作数都转换为数字并执行加

##  <a name="~运算符">~运算符</a>
`~`，被称为“按位不运算符”，`~n`等价于 `- n - 1`。//返回一个整数
>
    ~15.5 // -16
    ~'15.5' // -16
    ~('daa') // -1
    ~(NaN)  // -1

`~~n`：可用于取整;
`~~n` 等价于  - (- n - 1) - 1 = n + 1 - 1 = n
>

    ~~15.5 // 15
    ~~(NaN) // 0

## <a name="比较运算符"><,>,<=,>=的比较规则</a>

所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较  
转换规则如下:
>
    如果操作数是对象，转换为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错  
    经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的16位unicode值的大小）  
    否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较

# <a name="===、==、Object.is()判断">===、==、Object.is()判断</a>
![===、==、Object.is()](/img/===.png)

## ===运算符判断
* 如果两个值不是相同类型，它们不相等
* 如果两个值都是null或者都是undefined，它们相等
* 如果两个值都是布尔类型true或者都是false，它们相等
* 如果其中有一个是NaN，它们不相等
* 如果都是数值型并且数值相等，他们相等， -0等于0(+0)
* 如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者* 容上不等，它们不相等；两个字符串显示结果相同但是编码不同==和===都认为他们不* 等
* 如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等

## ==运算符判断
* 如果两个值类型相同，按照===比较方法进行比较
* 如果类型不同，使用如下规则进行比较
  * 如果其中一方是null，另一方是undefined，则相等
  * 如果其中一方是数字，那么另一方就会被转为数字，再比较
  * 如果有布尔类型，转为数字，再比较
  * 如果一方是对象，另一方是基本数据类型，将对象转换为原始类型，再比较
  * 如果其中一方是NaN，它们不相等(`NaN == NaN  //false`)
  * 其他所有情况都认为不相等

![==](/img/==.jpg)

### 思考: [] == ![]
* 首先，我们需要知道 ! 优先级是高于 == 
* ![] 引用类型转换成布尔值都是true,因此![]的是false 
* 当其中一方是 boolean，将 boolean 转为 number 再进行判断，false转换成 number，对应的值是 0.
* 有一方是 number，那么将object也转换成Number,空数组转换成数字，对应的值是0.(空数组转换成数字，对应的值是0，如果数组中只有一个数字，那么转成number就是这个数字，其它情况，均为NaN)
* 0 == 0; 为true

### `对象转原始类型`

对象在转换类型的时候，会调用内置的 [ToPrimitive(obj,preferredType)](https://tc39.es/ecma262/#sec-ordinarytoprimitive) 函数，第一个obj为被转换的对象，第二个
preferredType为希望转换成的类型（默认为空，接受的值为Number或String）

* preferredType为String（默认String）
  1. 如果obj为原始值，直接返回；
  2. 否则调用 obj.toString()，如果执行结果是原始值，返回该值；
  3. 否则调用 obj.valueOf()，如果执行结果是原始值，返回该值；
  4. 否则抛异常

* preferredType为Number
  1. 如果obj为原始值，直接返回；
  2. 否则调用 obj.valueOf()，如果执行结果是原始值，返回该值；
  3. 否则调用 obj.toString()，如果执行结果是原始值，返回该值；
  4. 否则抛异常


当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。
```js
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  },
  [Symbol.toPrimitive]() {
    return 2
  }
}
1 + a // => 3
```

##  Object.is()
为true的情况
* 都是 undefined
* 都是 null
* 都是 true 或者都是 false
* 都是完全相同的字符串，
* 都是数字并且
  * 都是正零，0 或 +0 // (Object.is(0,+0) ==>true)
  * 都是负零 -0 // (Object.is(0,-0) ==>false)
  * 都是 NaN 
  * 都是除零和 NaN 外的其它同一个数字
* 都指向同一个对象
  ```js
  let a = {}
  let b = a
  Object.is(a, b) // true
  Object.is({},{}) // false
  ```


这种相等性判断逻辑和传统的 == 运算不同，== 运算符会对它两边的操作数做隐式类型转换（如果它们类型不同），然后才进行相等性比较，（所以才会有类似 "" == false 等于 true 的现象），但 Object.is 不会做这种类型转换。

这与 === 运算符的判定方式也不一样。=== 运算符（和== 运算符）将数字值 -0 和 +0 视为相等，并认为 Number.NaN 不等于 NaN。

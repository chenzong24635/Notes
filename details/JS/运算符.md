
#  <a name="运算符">运算符</a>
![运算符优先级](/img/运算符优先级.png)
[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)


##  <a name="加运算符">+运算符</a>
>
    如果有操作数是对象，转换为原始值  
    此时如果有一个操作数是字符串，其他的操作数都转换为字符串并执行连接  
    否则：所有操作数都转换为数字并执行加

##  <a name="~运算符">~运算符</a>
`~`，被称为“按位不运算符”，`~n`等价于 `- n - 1`。//返回一个整数
>
    ~15.5 // -16
    ~'15.5' // -16
    ~('daa') // -1
    ~(NaN)  // -1

`~~n`：可用于取整;
`~~n` 等价于  - (- n - 1) - 1 = n + 1 - 1 = n
>

    ~~15.5 // 15
    ~~(NaN) // 0

## <a name="比较运算符"><,>,<=,>=的比较规则</a>

所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较  
转换规则如下:
>
    如果操作数是对象，转换为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错  
    经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的16位unicode值的大小）  
    否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较

# <a name="===、==、Object.is()判断">===、==、Object.is()判断</a>
![===、==、Object.is()](/img/===.png)

## ===运算符判断
* 如果两个值不是相同类型，它们不相等
* 如果两个值都是null或者都是undefined，它们相等
* 如果两个值都是布尔类型true或者都是false，它们相等
* 如果其中有一个是NaN，它们不相等
* 如果都是数值型并且数值相等，他们相等， -0等于0(+0)
* 如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者* 容上不等，它们不相等；两个字符串显示结果相同但是编码不同==和===都认为他们不* 等
* 如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等
    
## ==运算符判断
* 如果两个值类型相同，按照===比较方法进行比较
* 如果类型不同，使用如下规则进行比较
  * 如果其中一方是null，另一方是undefined，则相等
  * 如果其中一方是数字，那么另一方就会被转为数字，再比较
  * 如果有布尔类型，转为数字，再比较
  * 如果一方是对象，另一方是基本数据类型，将对象转换为原始值，再比较
  * 如果其中一方是NaN，它们不相等(`NaN == NaN  //false`)
  * 其他所有情况都认为不相等

![==](/img/==.jpg)

`对象转原始类型`
对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下：
* 如果已经是原始类型了，那就不需要转换了
* 调用 x.valueOf()，如果转换为基础类型，就返回转换的值
* 调用 x.toString()，如果转换为基础类型，就返回转换的值
* 如果都没有返回原始类型，就会报错


当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。
```js
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  },
  [Symbol.toPrimitive]() {
    return 2
  }
}
1 + a // => 3
```

##  Object.is()
为true的情况
* 都是 undefined
* 都是 null
* 都是 true 或者都是 false
* 都是完全相同的字符串，
* 都是数字并且
  * 都是正零，0 | +0 (Object.is(0,+0) ==>true)
  * 都是负零 -0 (Object.is(0,-0) ==>false)
  * 都是 NaN 
  * 都是除零和 NaN 外的其它同一个数字
* 都指向同一个对象
  ```js
  let a = {}
  let b =a
  Object.is(a,b) // true

  Object.is({},{}) // false

  ```


这种相等性判断逻辑和传统的 == 运算不同，== 运算符会对它两边的操作数做隐式类型转换（如果它们类型不同），然后才进行相等性比较，（所以才会有类似 "" == false 等于 true 的现象），但 Object.is 不会做这种类型转换。

这与 === 运算符的判定方式也不一样。=== 运算符（和== 运算符）将数字值 -0 和 +0 视为相等，并认为 Number.NaN 不等于 NaN。

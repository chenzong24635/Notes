## 代理模式

把对一个对象的访问, 交给另一个代理对象来操作.

* 虚拟代理
* 保护代理
* 缓存代理

### 虚拟代理: 将一些开销很大的对象，延迟到真正需要它的才去创建。

图片懒加载，先通过 laoding 图占位，异步加载图片，图片加载完成后再替换原先的 loading 图

```js
var preImage = (function () {
  var imgNode = document.createElement("img");
  document.body.appendChild(imgNode);
  var img = new Image();
  img.onload = function () {
    imgNode.src = img.src;
  };

  return {
    setSrc: function (src) {
      imgNode.src = "loading.gif";
      img.src = src;
    },
  };
})();

preImage.setSrc("http://xxx/xxx.jpg");
```

### 保护代理： 代理帮助本体过滤掉一些请求
```js
let Flower = function () {};
let xiaoming = {
  sendFlower: function (target) {
    target.receiveFlower();
  },
};
//B属于代理对象，可以帮助A对象过滤一些请求
let B = {
  receiveFlower: function () {
    //监听A的好心情
    A.listenGoodMood(() => {
      // new Flower()是一个大的开销对象
      let flower = new Flower();
      A.receiveFlower(flower);
    });
  },
};
//目标对象
let A = {
  receiveFlower: function (flower) {
    console.log("收到花", flower);
  },
  listenGoodMood: function (fn) {
    //延迟10秒
    setTimeout(() => {
      fn();
    }, 10000);
  },
};
xiaoming.sendFlower(B);
```

### 缓存代理:为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟原来的一致，可以直接返回之前存储的运算结果
```js
const getFib = (number) => {
  if (number <= 2) {
    return 1;
  } else {
    return getFib(number - 1) + getFib(number - 2);
  }
};
const getCacheProxy = (fn, cache = new Map()) => {
  return new Proxy(fn, {
    apply(target, context, args) {
      const argsString = args.join(" ");
      if (cache.has(argsString)) {
        // 如果有缓存,直接返回缓存数据
        //console.log(`输出${args}的缓存结果: ${cache.get(argsString)}`);
        return cache.get(argsString);
      }
      const result = fn(...args);
      cache.set(argsString, result);

      return result;
    },
  });
};
const getFibProxy = getCacheProxy(getFib);
// 控制台输入两次getFibProxy(40)，发现第二次明显快了
```

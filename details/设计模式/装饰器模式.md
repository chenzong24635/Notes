## 装饰器模式

不改变现有对象结构的情况下，动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象


```js
let plane = {
  fire () {
    console.log("发射普通子弹");
  },
};
let missileDecorator = function () {
  console.log("发射导弹");
};

let fire1 = plane.fire;
plane.fire = function () {
  fire1();
  missileDecorator();
};

plane.fire();
// 分别输出： 发射普通子弹 发射导弹、
```

用AOP装饰函数
```js
Function.prototype.before = function (beforefn) {
  let __self = this;
  return function (...args) {
    // 先执行 beforefn ，
    beforefn.apply(this, args);
    return __self.apply(this, args);
  };
};
Function.prototype.after = function (afterfn) {
  let __self = this;
  return function (...args) {
    let res = __self.apply(this, args);
    afterfn.apply(this, args);
    return res
  };
};
let button = document.getElementById("button");
function btnClick() {
  console.log('按钮点击了');
}
btnClick = btnClick.before(function() {
  console.log('在按钮`点击之前`做点事情');
}).after(function() {
  console.log('在按钮`点击之后`做点事情');
})
button.onclick= btnClick
```
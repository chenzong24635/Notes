## 浏览器页面渲染
浏览器工作原理
1.用户界面 
2.网络 
3.UI后端 
4.数据存储 
5.浏览器引擎 
6.渲染引擎 
7.js解析  


![render](/img/render.png)
![render](/img/render1.png)


页面渲染可分为下面5个步骤：
1. 构建 DOM 树：HTML被解析成DOM树
2. 生成 StyleRules 样式表：CSS被解析成CSSOM树
3. 构建 Render 树：结合DOM树和CSSOM树，生成一棵渲染树(Render Tree)
4. 布局(Layout): 根据 Render 树结构，确定每个元素在屏幕内的位置与大小 --回流
5. 绘制(Painting)：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。--重绘
6. 渲染完成，展示页面

4、5是最耗时的部分，这两步合起来即 渲染。


[了解重绘-回流](/details\面试题\JS面试题\重绘-回流.md)

### 注意点：

* `DOM树的构建是文档加载完成开始的？`构建DOM数是一个渐进过程，为达到更好用户体验，渲染引擎会尽快将内容显示在屏幕上。它不必等到整个HTML文档解析完毕之后才开始构建render数和布局。

* `Render树是DOM树和CSSOM树构建完毕才开始构建的吗？`这三个过程在实际进行的时候又不是完全独立，而是会有交叉。会造成一边加载，一遍解析，一遍渲染的工作现象。

* `CSS 的解析注意点？`CSS的解析是从右往左逆向解析的(从DOM树的下－上解析比上－下解析效率高)，嵌套标签越多，解析越慢。


### CSS加载会造成阻塞吗

先给出结论
* CSS不会阻塞DOM解析，但会阻塞DOM渲染。
* CSS会阻塞JS执行，并不会阻塞JS文件下载

DOM 和 CSSOM通常是并行构建的，所以`「CSS 加载不会阻塞 DOM 的解析」`。

然而由于Render Tree 是依赖DOM Tree和 CSSOM Tree的，所以它必须等到两者都加载完毕后，完成相应的构建，才开始渲染，因此，`「CSS加载会阻塞DOM渲染」`

由于 JavaScript 是可操纵 DOM 和 css 样式 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。
因此为了防止渲染出现不可预期的结果,浏览器设置 `「GUI 渲染线程与 JavaScript 引擎为互斥」`的关系。

有个需要注意的点就是：`「有时候JS需要等到CSS的下载，这是为什么呢？」`

仔细思考一下，其实这样做是有道理的，如果脚本的内容是获取元素的样式，宽高等CSS控制的属性，浏览器是需要计算的，也就是依赖于CSS。浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，再执行JS。
JS文件下载和CSS文件下载是并行的，有时候CSS文件很大，所以JS需要等待。
因此,样式表会在后面的 js 执行前先加载执行完毕,`所以「css 会阻塞后面 js 的执行」`。

### 为什么JS会阻塞页面加载

先给出结论👇  
* `「JS阻塞DOM解析」`，也就会阻塞页面  

```
由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。

因此为了防止渲染出现不可预期的结果,浏览器设置 「GUI 渲染线程与 JavaScript 引擎为互斥」的关系。

当 JavaScript 引擎执行时 GUI 线程会被挂起,GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。

当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个队列中,直到 JS 程序执行完成,才会接着执行。

因此如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉。

```

因此建议script标签放在body下面,或添加 async、defer属性：
因为：JS代码在加载完之后是立即执行的，且JS代码执行时会阻塞页面的渲染。

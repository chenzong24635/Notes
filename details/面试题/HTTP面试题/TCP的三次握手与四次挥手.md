## TCP的三次握手与四次挥手

[TCP的三次握手与四次挥手理解](https://blog.csdn.net/qq_38950316/article/details/81087809)

| 字段| 	含义
|:--|:--
| URG	| 紧急指针是否有效。为1，表示某一位需要被优先处理
| ACK	| 确认号是否有效，一般置为1。
| PSH	| 提示接收端应用程序立即从TCP缓冲区把数据读走。
| RST	| 对方要求重新建立连接，复位。
| SYN	| 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1
| FIN	| 希望断开连接。

### 三次握手：
* 第一次握手：建立连接时，客户端发送 SYN 包（SYN=x）到服务器，并进入SYN_SEND状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

* 第二次握手：服务器收到 SYN 包，必须确认客户的SYN（ACK=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，即，此时服务器进入SYN_RECV状态；

* 第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。客户端与服务器正式开始传送数据
  >
      ----第二次握手后的状态，称为半连接，服务器会创建半连接队列。若收到第三次握手确认，则删除当前连接，若未收到，每隔一段时间重传第二次握手信息，直至半连接超时
      ----若半连接队列满了   ，丢弃新请求---半连接攻击

      目的：
      为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。
      或则说 解决“网络中存在延迟的重复分组”的问题。

![tcp三次握手](/img/tcp三次握手.jpg)

### 如何关闭连接（四次挥手）：
TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)

* 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 
* 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样一个FIN将占用一个序号。 
* 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 
* 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1

![tcp四次挥手](/img/tcp四次挥手.jpg)


简易图
![三次握手四次挥手](/img/tcp.jpg)


## 为什么连接的时候是三次握手，关闭的时候却是四次握手？

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。

但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。
只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手
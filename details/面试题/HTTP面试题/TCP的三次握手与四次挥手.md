# TCP的三次握手与四次挥手
[](https://zhuanlan.zhihu.com/p/86426969)
[TCP的三次握手与四次挥手理解](https://blog.csdn.net/qq_38950316/article/details/81087809)

| 字段| 	含义
|:--|:--
| SYN	| 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1
| ACK	| 确认号是否有效，有两个取值：0和1，为1的时候表示应答域有效，反之为0。
| ISN	| 初始序号,是动态生成的,可以看作是一个32比特的计数器，每4ms加1。
| URG	| 紧急指针是否有效。为1，表示某一位需要被优先处理
| PSH	| 提示接收端应用程序立即从TCP缓冲区把数据读走。
| RST	| 对方要求重新建立连接，复位。
| FIN	| 希望断开连接。


需要的信息：
* SYN： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。
* ISN： 初始序号,是动态生成的,可以看作是一个32比特的计数器，每4ms加1。
* ACK： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1
* FIN：完结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

## 三次握手：
三次握手其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。

进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。

进行三次握手：
* 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（seq=x） 。此时客户端处于 `SYN_SEND` 状态。
  >请求报文中: SYN=1, 初始序号seq=x

* 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(seq=y)。同时会把客户端的 ISN + 1 作为ACK(ACK=x+1) 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 `SYN_RECV` 的状态。
  >在确认报文段中: SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。


* 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 `ESTABLISHED` 状态。服务器收到 ACK 报文之后，也处于 `ESTABLISHED 状态`，此时，双方已建立起了连接。
  >确认报文段 ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。

  >
      ----第二次握手后的状态，称为半连接，服务器会创建半连接队列。若收到第三次握手确认，则删除当前连接，若未收到，每隔一段时间重传第二次握手信息，直至半连接超时
      ----若半连接队列满了，丢弃新请求---半连接攻击

      目的：
      为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。
      或则说 解决“网络中存在延迟的重复分组”的问题。

![tcp三次握手](/img/HTTP/tcp三次握手.png)

### 为什么需要三次握手，两次不行吗？
第一次握手：客户端发送网络包，服务端收到了。
>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

第二次握手：服务端发包，客户端收到了。
>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。

第三次握手：客户端发包，服务端收到了。
>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。


试想如果是用两次握手，则会出现下面这种情况：
>
    如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。

### 什么是半连接队列
第二次握手后的状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。
若收到第三次握手确认，则删除当前连接，若未收到，每隔一段时间重传第二次握手信息，直至重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。

注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…


当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

### 三次握手过程中可以携带数据吗？
第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据

为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

## 如何关闭连接（四次挥手）：
TCP的连接的关闭需要发送四个包，因此称为四次挥手(four-way handshake)
刚开始双方都处于 ESTABLISHED 状态
* 第一次挥手：客户端请求断开连接，发送一个 FIN 报文，报文中会指定一个序列号ISN(seq=u)。此时客户端处于 `FIN_WAIT1` 状态。
  >连接释放报文：FIN=1，序列号seq=u

* 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值ISN +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。  
  >确认报文：ACK=1,seq=v,ack=u+1

* 第三次挥手：此时服务端请求断开连接，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。
  >请求关闭报文：ACK=1,FIN=1，seq=w,ack=u+1
  
* 第四次挥手：客户端收到 FIN 报文 之后，发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 `CLOSED` 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED`状态。
  >确认报文：ACK=1,seq=u+1,ack=w+1

![tcp四次挥手](/img/HTTP/tcp四次挥手.png)


简易图
![三次握手四次挥手](/img/tcp.jpg)


## 为什么连接的时候是三次握手，关闭的时候却是四次握手？

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。

但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。
只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手
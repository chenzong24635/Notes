## TCP的三次握手与四次挥手
[](https://zhuanlan.zhihu.com/p/86426969)
[TCP的三次握手与四次挥手理解](https://blog.csdn.net/qq_38950316/article/details/81087809)

| 字段| 	含义
|:--|:--
| SYN	| 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1
| ACK	| 确认号是否有效，一般置为1。
| ISN	| 初始序号,是动态生成的,可以看作是一个32比特的计数器，每4ms加1。
| URG	| 紧急指针是否有效。为1，表示某一位需要被优先处理
| PSH	| 提示接收端应用程序立即从TCP缓冲区把数据读走。
| RST	| 对方要求重新建立连接，复位。
| FIN	| 希望断开连接。

### 三次握手：
三次握手其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。

进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。

进行三次握手：
* 第一次握手：建立连接时，客户端发送 SYN 包（SYN=1,seq=x）到服务器，并进入SYN_SEND状态，等待服务器确认；
  * SYN：同步序列编号（Synchronize Sequence Numbers）。

* 第二次握手：服务器收到 SYN 包，确认客户的SYN，同时自己也发送一个SYN包（SYN=1， 确认号ACK=x+1， 初始序号seq=y），此时服务器进入SYN_RECV状态；

* 第三次握手：客户端收到 SYN 报文之后，向服务器发送确认包ACK(确认号ack=y+1,序号seq=x+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。客户端与服务器正式开始传送数据
  >
      ----第二次握手后的状态，称为半连接，服务器会创建半连接队列。若收到第三次握手确认，则删除当前连接，若未收到，每隔一段时间重传第二次握手信息，直至半连接超时
      ----若半连接队列满了，丢弃新请求---半连接攻击

      目的：
      为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。
      或则说 解决“网络中存在延迟的重复分组”的问题。

![tcp三次握手](/img/HTTP/tcp三次握手.png)

### 如何关闭连接（四次挥手）：
TCP的连接的关闭需要发送四个包，因此称为四次挥手(four-way handshake)

* 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 
* 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样一个FIN将占用一个序号。 
* 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 
* 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1

![tcp四次挥手](/img/HTTP/tcp四次挥手.png)


简易图
![三次握手四次挥手](/img/tcp.jpg)


## 为什么连接的时候是三次握手，关闭的时候却是四次握手？

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。

但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。
只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手
## <a name="0.1+0.2">0.1+0.2!=0.3</a>

- 原因：

在进制转换和进阶运算的过程中出现精度损失。

JavaScript 中的 number 类型就是浮点型，数字和浮点精度的处理相同，JavaScript 中的浮点数采用 IEEE-754 格式的规定，这是一种二进制表示法，可以精确地表示分数，比如 1/2，1/8，1/1024，每个浮点数占 64 位。但是，二进制浮点数表示法并不能精确的表示类似 0.1 这样 的简单的数字，会有舍入误差。  
由于采用二进制，JavaScript 也不能有限表示 1/10、1/2 等这样的分数。在二进制中，1/10(0.1)被表示为 0.00110011001100110011…… 注意 0011 是无限重复的，这是舍入误差造成的，所以对于 0.1 + 0.2 这样的运算，操作数会先被转成二进制，然后再计算：  
0.1 => 0.0001 1001 1001 1001…（无限循环）  
0.2 => 0.0011 0011 0011 0011…（无限循环）  
双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串 0.0100110011001100110011001100110011001100...因浮点数小数位的限制而截断的二进制数字，这时候，再把它转换为十进制，就成了 0.30000000000000004。

- 解决：

  >

      先升幂再降幂

      使用内置的 toPrecision() 和 toFixed() 方法，注意，返回值字符串。

      Number.EPSILON(极小的常量; === Math.pow(2, -52))
          //设置“能够接受的误差范围”。
          function withinErrorMargin (left, right) {
            return Math.abs(left - right) < Number.EPSILON;
          }

          withinErrorMargin(0.1 + 0.2, 0.3) // true





[](https://segmentfault.com/a/1190000019891825)
[「查缺补漏」巩固你的HTTP知识体系](https://juejin.im/post/6857287743966281736)

# HTTP

HTTP协议 ：Hyper Text Transfer Protocol（超文本传输协议）,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。

HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。

HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。

## HTTP特点

* 简单快速

* 灵活

* HTTP是无连接：
  无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

* HTTP是无状态：
  HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

* HTTP是媒体独立的：
  这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。

## HTTP 缺点
* 无状态:有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等，另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说。

* 明文传输，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。

* 队头阻塞，当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。


## HTTP1.0 HTTP1.1 HTTP2.0版本之间的差异
### http 1.0

* 早先1.0的HTTP版本，是一种无状态、无连接的应用层协议。

* HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。
  
这种无状态性可以借助cookie/session机制来做身份认证和状态记录。而下面两个问题就比较麻烦了。
  * 首先，无连接的特性导致最大的性能缺陷就是无法复用连接。每次发送请求的时候，都需要进行一次TCP的连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率非常低。

  * 其次就是队头阻塞（headoflineblocking）。由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，那么下一个请求就不发送，同样的后面的请求也给阻塞了。

Http 1.0的致命缺点,就是无法复用TCP连接和并行发送请求，这样每次一个请求都需要三次握手，而且其实建立连接和释放连接的这个过程是最耗时的，传输数据相反却不那么耗时。还有本地时间被修改导致响应头expires的缓存机制失效的问题

### Http 1.1

* 引入了持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 keep-alive 来设置

* 引入了管道机制（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个
请求，进一步改进了HTTP协议的效率。

* HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。

* 支持断点续传，通过使用请求头中的 Range 来实现。

* 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。

* 新增方法：PUT、 PATCH、 OPTIONS、 DELETE。


`Http 1.1的致命缺点：`
* 明文传输：在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性
  
* 其实还是没有解决无状态连接的

* 队头阻塞：HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，当有多个请求同时被挂起的时候 就会拥塞请求通道

* 臃肿的消息首部:HTTP/1.1能压缩请求内容,但是消息首部不能压缩;在现今请求中,消息首部占请求绝大部分(甚至是全部)也较为常见.

我们也可以用dns-prefetch和 preconnect tcp来优化～
```html
<link rel="preconnect" href="//example.com" crossorigin>
<link rel="dns=prefetch" href="//example.com">
```

### Http 2.0
* 二进制分帧：这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧。

* 头部压缩：HTTP 1.1版本会出现 「User-Agent、Cookie、Accept、Server、Range」 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 HPACK 算法进行压缩。

* 多路复用：复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。

* 服务器推送：允许服务器未经请求，主动向客户端发送资源，即服务器推送。

* 请求优先级：可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验


### HTTPS 
HTTPS 并非是一种新的应用层协议。只是 HTTP 通信接口部分用 SSL（安全套接层 SecureSocket Layer）和 TLS（传输层安全 Transport Layer Security）协议代替而已，而安全性的保证正是 SSL/TLS 所做的工作。

可以把HTTPS理解成 `HTTPS = HTTP + SSL/TLS`

![http-https](/img/http-https.png)



### HTTP与HTTPS区别  

* HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

* HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页。

* HTTPS标准端口443，HTTP标准端口80。

* HTTPS需要用到SSL证书，而HTTP不用

### 既然 HTTPS 那么安全可靠，那为何所有的 Web 网站不一直使用 HTTPS
因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。

因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信。

此外要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买

### HTTP2的多路复用和HTTP1.1中的长连接复用有什么区别？
> 
    HTTP/1.0 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
    HTTP/1.1 可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；

    HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；


## Web访问过程
```txt
（1）客户端在浏览器输入URL  
（2）客户端操作系统左DNS解析，获得目标服务器的IP地址  
（3）客户端操作系统打开一个自由短裤。向服务器发起连接请求  
（4）经过三次握手，服务器端确认与该客户端的连接，打开一个自由端口与该客户端通信  
（5）客户端开始请求数据——以4KB为大小的一个又一个请求数据包——发送HTTP Request  
（6）服务器开始接收请求数据包，接收完成后，处理接收到的数据——Request Handling  
（7）服务器开始向客户端发送以4KB为大小的响应数据——发送HTTP Response  
（8）响应结束之后，服务器会经过四次握手，断开连接，关闭各自的自由端口  
```

## HTPP缓存：强缓存、协商缓存
[http缓存](/details\HTTP\http缓存.md)

## HTTP协议详解
>
    RFC:  Request For Comment(www.rfc.org)，一项协议在正式发布之前的专家制定的意见征求稿，如RFC-405
    HTTP协议的详细格式也是由一篇RFC文档确定的。其中规定了两种消息的格式：
    Request Message  请求消息/报文
    Response Message  响应消息/报文


HTTP请求到服务器的请求消息组成部分：请求行（request line）、请求头部（header）、空行、请求数据
* 请求体只有在POST方法下存在，常见的场景是表单提交。

![requestheader](/img/requestheader.jpg)

HTTP响应也由四个部分组成：状态行、消息报头、空行和响应正文。


### 请求方法：指定了客户端想对指定的资源/服务器作何种操作；
HTTP1.0请求方法： GET, POST 和 HEAD方法。

HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

* GET		请求指定的页面信息，并返回实体主体。
  
* HEAD	类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头

* POST	向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。该请求可能会导致新的资源的建立和/或已有资源的修改。

* PUT		从客户端向服务器传送的数据取代指定的文档的内容。

* DELETE	请求服务器删除指定的页面。

* CONNECT 预留给能够将连接改为管道方式的代理服务器。

* OPTIONS 允许客户端查看服务器的性能。

* TRACE	回显服务器收到的请求，主要用于测试或诊断。


[GET和POST区别](https://zhuanlan.zhihu.com/p/22536382)
<!-- ![GET和POST区别](/img/getpost.png) -->

| |GET|POST
|:--|:--|:--
|浏览器后退/刷新|无害|会再次提交请求
|收藏为书签|能 |否
|缓存|能|否
|编码类型|	application/x-www-form-urlencoded	|application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。
|请求参数会被完整保留在浏览器历史记录|是|否
|数据长度大小|2k|无限制
|参数的数据类型|只允许ASCII字符|无限制，也允许二进制数据
|安全性|url明文传输|较GET安全，通过body传输
|可见性	|数据在 URL 中对所有人都是可见的|	数据不会显示在 URL 中


但是： 
GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

GET产生一个TCP数据包：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

POST产生两个TCP数据包：对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。


### HTTP请求和响应优化
>
    减少DNS次数
    使用持久连接
    减少请求次数，设置资源的合理的Expires时间、缓存时长
    缩短响应处理时间——使用数据库数据缓存、动态页面静态化、AJAX
    减少响应数据的长度——启用数据压缩    



### 数据缓存优点：
>
    减少数据传输量
    节省服务器宽带
    减低对服务器的资源消耗和运行要求
    减低由于远距离所造成的加载延时


### 同源策略与跨域
同源策略是浏览器的一种安全策略
所谓同源是指，域名，协议，端口完全相同
例如http://www.example.com/
>
    http://api.example.com/detail.html	不同源	域名不同
    https//www.example.com/detail.html	不同源	协议不同
    http://www.example.com:8080/detail.html不同源	端口不同
    http://api.example.com:8080/detail.html	不同源	域名、端口不同
    https://api.example.com/detail.html	不同源	协议、域名不同
    https://www.example.com:8080/detail.html不同源	端口、协议不同
    http://www.example.com/detail/index.html同源	只是目录不同

### 协议，端口

| 协议 | 默认端口号 | 协议基本作用
:-:|      :-:|       :-: |
| FTP     | 21        | 文件上传、下载
| DNS     | 53        | 域名解析
| HTTP    | 80        | 超文本传输
| HTTPS   | 443       | 加密传输的HTTPS
| SSH	  | 22	      | 安全的远程登录
| TELNET  | 23	      | 远程登录
| SMTP 	  | 25	      | 邮件传输
| POP3    | 109	      | 邮件接收
| NETBIOS | 137、138、139 | 网上邻居传输文件

### 几种常见的应用层协议：
>
    (1)DNS： Domain Naming Service，域名解析服务，一台DNS服务器可以帮助客户端进行域名解析服务，即把一个域名解析为该域名对应的IP地址
    (2)FTP： File Transfer Protocol，文件传输协议，可用于在服务器与客户端之间传递文件，文件下载：S给C传文件；文件上传：C给S传文件。----ftp://tom:123456@127.0.0.1:21
    (3)TELNET：通过TELNET客户端，可以远程登录到启动了TELNET服务的远程服务器，在远程实施对服务器的控制。如远程控制公司在“阿里云”购买的服务器。注意：TELNET协议传输过程中都是明文的，不安全的，现在基本已经被SSH代替了。


## HTTP状态码:
    由三个十进制数字组成，第一个十进制数字定义了状态码的类型

分为5种类型：
* 1**	临时响应，只包含状态行和某些可选的响应头信息。服务器收到请求，需要请求者继续执行操作
* 2**	请求成功，操作被成功接收并处理
* 3**	重定向，需要进一步的操作以完成请求
* 4**	客户端错误，请求包含语法错误或无法完成请求
* 5**	服务器错误，服务器在处理请求的过程中发生了错误


常见的状态码：
* 200 请求成功
* 301 资源永久重定向
* 302 临时重定向
* 304 请求的资源未修改
* 400 客户端请求的语法错误
* 401 未被授权，需要身份验证，例如token信息等
* 403 请求被拒绝
* 404 请求资源不存在
* 405 服务器禁止使用该方法
* 500 服务端错误
* 503 服务器暂时处于超负载或正在停机维护,暂时无法使用


所有的状态码：
| 状态码  |	名称 描述 |
:-:| :-|
| 100 |	Continue 继续 。客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收	
| 101 | Switching Protocols	切换协议。 服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如切换到HTTP的新版本协议
| 200 | OK 请求成功。 一般用于GET与POST请求
| 201 | Created	已创建  。 成功请求并创建了新的资源
| 202 | Accepted 已接受 。已经接受请求，但未处理完成
| 203 | Non-Authoritative Information	非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本
| 204 | No Content 无内容。 服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档
| 205 | Reset Content 重置内容。  服务器处理成功，用户终端（例如：浏| 览器）应重置文档视图。可通过此返回码清除浏览器的表单域
| 206 | Partial Content	部分内容。 服务器成功处理了部分GET请求
| 300 | Multiple Choices 多种选择。 请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择
| 301 | Moved Permanently 永久重定向。 请求的资源已被永久的移动到新URI，返回信 息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
| 302 | Found 临时重定向。 资源只是临时被移动。客户端应继续使用原有URI;但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307
| 303 | See Other 查看其它地址。 使用GET和POST请求查看
| 304 | Not Modified	未修改。 所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
| 305 | Use Proxy 使用代理。 所请求的资源必须通过代理访问
| 306 | Unused | 已废弃
| 307 | Temporary Redirect 临时重定向。与302类似,但在重定向时不会改变 method
| 400 | Bad Request	客户端请求的语法错误，服务器无法理解
| 401 | Unauthorized	未授权 请求要求用户的身份认证
| 402 | Payment Required 保留，将来使用
| 403 | Forbidden 禁止  服务器理解请求客户端的请求，但是拒绝执行此请求
| 404 | Not Found 未找到 服务器无法根据客户端的请求找到资源（网页）。 网站设计人员可设置"您所请求的资源无法找到"的个性页面
| 405 | Method Not Allowed 客户端请求中的方法被禁止
| 406 | Not Acceptable 服务器无法根据客户端请求的内容特性完成请求
| 407 | Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权
| 408 | Request Time-out	服务器等待客户端发送的请求时间过长，超时
| 409 | Conflict	服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突
| 410 | Gone	客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410 代码，网站设计人员可通过301代码指定资源的新位置
| 411 | Length Required	服务器无法处理客户端发送的不带Content-Length的请求信息
| 412 | Precondition Failed	客户端请求信息的先决条件错误
| 413 | Request Entity Too Large	由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息
| 414 | Request-URI Too Large	请求的URI过长（URI通常为网址），服务器无法处理
| 415 | Unsupported Media Type	服务器无法处理请求附带的媒体格式
| 416 | Requested range not satisfiable	客户端请求的范围无效
| 417 | Expectation Failed	服务器无法满足Expect的请求头信息
| 
| 500 | Internal Server Error	服务器内部错误，无法完成请求
| 501 | Not Implemented	服务器不支持请求的功能，无法完成请求
| 502 | Bad Gateway	充当网关或代理的服务器，从远端服务器接收到了一个无效的请求
| 503 | Service Unavailable	由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中
| 504 | Gateway Time-out	充当网关或代理的服务器，未及时从远端服务器获取请求
| 505 | HTTP Version not supported	服务器不支持请求的HTTP协议的版本，无法完成处理


情况一：
```ts
let c: A | B = {};
c.age = 222; // ok

c.name; // error
c.name = 'da'; // error
(<A>c).name; // ok
(<A>c).name = 'ad'; // ok
```
???为何, 定义、获取name属性需要断言，而age不需要；
此时 报错`类型“B”上不存在属性“name”。`;

再看  
情况二：
```ts
let c: A | B = {
  sex: 'man'
};
c.name = 'da'; // ok

c.age = 423; //error
(<B>c).age = 423; // ok
console.log(c);
```
此时 定义age属性时 c.age，报错```类型“A”上不存在属性“age”```

根据上面情况可知，情况一时，c= {}时，变量c绑定接口B（接口B 只有一个可读属性age，因此可定义空对象），而要定义或获取A接口的属性时，直接定义接口A的属性会报错，如：``` c.name = 423 //会报错 ```;此时需要对其接口断言，如：```(<A>c).name = 'ad';```；  
同样 情况二也是如此，对象c只定义了sex属性，其接口默认为A，

你以为这样就结束了

此时再看

情况三
```ts
let c: A | B = {
  sex: 'man',
  age: 3434
};
c.age = 5335; // error

(<B>c).age; // ok
(<B>c).age = 423; // ok
console.log((<B>c).age);
```
c.age 报错：```类型“A | B”上不存在属性“age”。类型“A”上不存在属性“age”。```
???
按上面情况，我现在 对变量c同时定义A，B接口属性，应该可以随意或定义c的变量，然而现实却是papapa

因此，获取或重新定义 一个联合类型的变量的属性时，还是需要断言：(<接口名>变量名).变量属性名 ：(<B>c).age
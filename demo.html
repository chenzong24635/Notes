<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html;" charset="UTF-8" />
  <!-- <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"/>-->
  <title></title>
  <!-- <link rel="icon" href="favicon.gif" type="images/gif" /> -->
  <!-- <link rel="stylesheet" href="./css/base.css" /> -->
  <style>
    .click {
      width: 100px;
      height: 100px;
      color: #000;
      border: 1px solid red;
    }

    #click {
      color: red
    }
  </style>
</head>

<body>
  <div class="click" id="click" style="color:gold">click</div>
  <input type="text" id="ipt">
  <script>
    var arr = [1, 2, 4, 0, 3, 1, 99]
document.onkeyup = function (event) {
  let e = event ? event : window.event
  if (e.keyCode === 13) {
    alert('您按了回车键。')
  }
}

    function bubbleSort(arr) {
      let len = arr.length;
      for (let i = 0; i < len; i++) {
        for (let j = 0; j < len - 1 - i; j++) {
          if (arr[j] > arr[j + 1]) { //相邻元素两两对比
            [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];
          }
        }
      }
      return arr;
    }
    // console.log(bubbleSort(arr))

    function bubble(arr) {
      var len = arr.length
      for (var i = 0; i < len; i++) {
        for (var j = 0; j < len - i; j++) {
          if (arr[j + 1] < arr[j]) {
            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
          }
        }
      }
      return arr
    }
    // console.log(bubble(arr))
    function quickSort(arr) {
      if (arr.length <= 1) {
        return arr;
      }
      //选择"基准"（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集
      var pivotIndex = Math.floor(arr.length / 2);
      var pivot = arr.splice(pivotIndex, 1)[0];
      var left = [];
      var right = [];
      //开始遍历数组，小于"基准"的元素放入左边的子集，大于基准的元素放入右边的子集。
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] < pivot) {
          left.push(arr[i]);
        } else {
          right.push(arr[i]);
        }
      }
      //用递归不断重复这个过程，就可以得到排序后的数组。
      return quickSort(left).concat([pivot], quickSort(right));
    };
    // console.log(quickSort(arr))
    var obj = {
      number: 1,
      arr: [],
      str: 'str',
      obj: {
        a: 'obj a',
        b: {
          arr: [1, 2, 5]
        }
      },
      func: function () {
        console.log('func')
      }
    }


    function deepClone1(objCloned) {
      let obj = Array.isArray(objCloned) ? [] : {};
      if (objCloned && typeof objCloned === "object") {
        for (key in objCloned) {
          if (objCloned.hasOwnProperty(key)) {
            // 判断 obj 子元素是否为对象，如果是，递归复制
            if (objCloned[key] && typeof objCloned[key] === "object") {
              obj[key] = deepClone1(objCloned[key]);
            } else {
              // 如果不是，简单复制
              obj[key] = objCloned[key];
            }
          }
        }
      }
      return obj;
    }

    function deepClone(objCloned, obj) {
      var obj = obj || {};
      for (var key in objCloned) {
        if (typeof objCloned[key] === 'object') {
          obj[key] = (objCloned[key].constructor === Array) ? [] : {};
          deepClone(objCloned[key], obj[key]);
        } else {
          obj[key] = objCloned[key];
        }
      }
      return obj;
    }

    let obj1 = deepClone(obj);
    let obj2 = deepClone1(obj)
    obj1.name = 'obj1'
    obj1.obj.a = 'obj1 a'
    obj2.name = 'obj2'
    obj2.obj.a = 'obj2 a'
    console.log(obj);
    console.log(obj1);
    console.log(obj2);

    function debounce(fn, delay = 500) {

    }

    function sayHi() {
      console.log('成功');
    }
  </script>
</body>

</html>
![a](../marigna.webp)

[]()

[正则表达式30分钟入门教程](https://deerchao.cn/tutorials/regex/regex.htm#mission)

[正则](http://tool.oschina.net/uploads/apidocs/jquery/regexp.html)

[正则调试](https://regex101.com/)

# 元字符
| 字符| 描述| |
|:---|:---|:--|
| .  | 匹配除换行符（\n）以外的任意字符(匹配所有([\d\D]\*)或([\s\S]\*)或([\w\W]\*) 或开启单行模式(s)) | /.ar/g => The `car par`ked in the `gar`age.  |
| () | 数据分界 |  |
| [] | 匹配方括号内的任意字符 | [abc]会匹配a或b或c |
| [^] | 匹配除了方括号内的任意字符 | [^abc]会匹配除a或b或c外的字符 |
| \ | 转义字符| 转义特殊字符为普通字符 \\[\\] |
| ^ | 匹配字符串的开始| 数字开头^\d|
| $ | 匹配字符串的结束| 数字结尾\d$|
| \| | 或运算符, 多选一 匹配符号前或后的字符| /(c\|g\|p)ar/g => The `car` is `par`ked in the `gar`age. |
| \w | 匹配任何单词字符.等价于[A-Za-z0-9_] ||
| \W | 匹配任何非单词字符.等价于[^A-Za-z0-9_] ||
| \s | 匹配任意空白符,包括空格、制表符、换页符等等。等价于[\f\n\r\t\v]。||
| \S | 匹配任意非空白符,等价于[^\f\n\r\t\v]||
| \d | 匹配数字 (等价于[0-9] )||
| \D | 匹配非数字 (等价于[^0-9] [^\d])||
| \b | 匹配一个单词边界 （单词的开始或结束）| “er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。|
| \B | 匹配一个非单词边界 （非单词的开始或结束） | “er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”|
| \f | 匹配一个换页符。等价于\x0c和\cL。 |
| \n | 匹配一个换行符。等价于\x0a和\cJ。 |
| \r | 匹配一个回车符。等价于\x0d和\cM。 |
| \t | 匹配一个制表符。等价于\x09和\cI。 |
| \v | 匹配一个垂直制表符。等价于\x0b和\cK|

>
    单行模式s：更改.的含义，使它与每一个字符匹配（包括换行符\n）

    匹配a标签包括其内容
    '<a href="daad" class="b"> ddad \n </a>'.match(/<a[^>]+>.*(<\/a>)$/gs)
    等同于
    '<a href="daad" class="b"> ddad \n </a>'.match(/<a[^>]+>([\d\D]*)(<\/a>)$/g)

    多个a标签
    '<a  class="b"> ddad \n </a> <a href="daad" class="aa"> ddad \n </a>'.match(/<a[^>]*?>([^<]*)<\/a>/g)

# 修饰符
| 字符| 描述| |
|:---|:---|:--|
| i | 忽略大小写 |
| g | 全局搜索 |
| s | 单行模式:	更改.的含义，使它与每一个字符匹配（包括换行符\n）
| m | 多行模式: 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)|

`多行模式和单行模式没有任何关系.能同时使用`


# 贪婪、懒惰
| 字符| 描述| |
|:---|:---|:--|
|`贪婪`| |
|?	 | 匹配重复0或1次 其之前的字符 |
|*	 | 匹配重复>=0次 其之前的字符 |
|+	 | 匹配重复>=1次 其之前的字符 |
|{n} |	匹配重复n次 的字符 |
|{n,} | 匹配重复 >=n次 的字符 |
|{n,m}| 匹配重复n到m次 的字符 |
| `懒惰` |其后加? 表示尽可能少重复 |
| ??     |重复0或1次，但尽可能少重复|
| *?	  | 重复>=0次，但尽可能少重复 |
| +?	  | 重复>=1次，但尽可能少重复|
| {n,m}? |重复n到m次，但尽可能少重复|
| {n,}?  |重复n次以上，但尽可能少重复|

# 零宽断言
断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，意思正则也可以像人类那样断定什么什么，比如"ss1aa2bb3",正则可以用断言找出aa2后面有|没有bb3，也可以找出aa2前面有|没有ss1.

零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。



| 字符| 定义| | |
|:---|:---|:---|:---|
| ?=exp| 零宽度正预测先行断言-存在 | 断言此位置的后面能匹配表达式exp | /(T\|t)he(?=\sfat)/g => `The` fat cat sat on a fat . //匹配的the或The的后面要求 有着空白符及fat字符|
| ?<=exp | 零宽度正回顾后发断言-存在 |断言此位置的前面能匹配表达式 | /(?<=(T\|t)he\s)fat/g => The `fat` cat sat on a fat. //匹配的fat字符 之前要求有着the或The及空白符 |
| ?!exp | 零宽度负预测先行断言-排除 | 断言此位置的后面不能匹配表达式exp  | /(T\|t)he(?!\sfat)/g => The fat cat sat on `the` mat. //匹配的the或The的后面要求 没有空白符及fat字符 |
| ?<!exp | 零宽度负回顾后发断言-排除 |断言此位置的前面不能匹配表达式exp | /(?<!(T\|t)he\s)fat/g => The fat cat sat on a `fat`. //匹配的fat字符 之前要求没有the或The及空白符 |

! 不存在；  
= 存在；  
\< 前面；  
没有\< 后面；

>
    "<span class=\"read-count\">阅读数：641</span>".match(/\d+(?=<\/span>)/gi)

    //["641"]
      
    (?!B)[A-Z]这种写法，其实它是[A-Z]范围里，排除B的意思，前置的(?!B)只是对后面数据的一个限定，从而达到过滤匹配的效果。

#  方法

* test：查询是否存在符合的字符
>
    reg.test(str) 返回boolean值：true|false

    

* match：查询所有符合的字符
>
    str.match(reg) //返回数组 | null

    'bNa '.match(/na/gi) ==> ['Na']

* replace： 替换所有符合的字符
>
    str.replace(reg,replacedElement) //返回替换后的字符串

    'bNa'.replace(/na/gi, 2) ==> 'b2'



# 常用
用户名：
数字字母下划线 m到n个字符
>
    /^[A-Za-z0-9_]{m,n}$/
    /\w{m,n}/

密码：  
数字字母 m到n个字符
>

    /^[A-Za-z0-9]{m,n}$/

校验中文
>
    /^[\\u4e00-\\u9fa5]{0,}$/

由数字、26个英文字母或下划线组成的字符串
>
    /^\w+$/

校验Email
>
    /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/
    /^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/


 校验身份证号码
>

    15位：
    ^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$
    
    18位：
    ^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$

    ^[1-9]\d{5}(18|19|20)\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$



校验金额
>
    金额校验，精确到2位小数。

    /^[0-9]+(.[0-9]{2})?$/

校验手机号
>



提取URL链接
>




移除HMTL中的注释
>
    /<!--(.*?)-->/

    '<!-- fsf -->对对对'.replace(/<!--(.*?)-->/, '') => 对对对

